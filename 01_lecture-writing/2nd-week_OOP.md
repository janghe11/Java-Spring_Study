# 객체지향 프로그래밍
* 날짜 : 2017년 4월 15일
* 장소 : 힐스터디 강남점 14번 부스
* 발표자 : 최용호

* **강의 자료(02_lecture-presentations)** : 객체지향 프로그래밍 기본
* **샘플 코드(03_sample-codes)** : https://github.com/YonghoChoi/javacafe-javastudy-2017.git
* 실습 소스 파일(04_practice-codes) :

## 객체지향 프로그래밍(OOP)
* 프로그래밍을 어떤 식으로 표현할거냐?의 관점(절차, 객체, 함수형...) / 패러다임
  * 개발자들을 위한 것임을 염두.(모든것을 객체로 풀어나가고 상호작용 및 관계를 맺겠다.)
* 각각의 객체는 메시지를 주고받고 처리할 수 있다.
* 객체
  * 모든 사물이 객체
  * 저장 공간(메모리)에 할당된 공간
  * 객체 참조 변수 : 메모리의 어느 영역에 주소가 담겨있다. 주소는 OS에게 물어보고 OS가 실제 메모리에 접근
  * 클래스를 생성 -> 속성 + 행위
* 클래스
  * 개념적인 클래스를 통해 실체화 된 것이 객체(인스턴스)
  * 필드(속성)와 메소드(행위)를 가진다.
  * 클래스 객체참조변수명 = new 클래스();
    * 저장공간이 생김.
    * new가 생성자를 호출.
  * 클래스 구성 멤버 : 필드, 생성자, 메소드
    * 클래스 생성시 제일 먼저 호출 : 생성자
    * 행위 : 메소드
    * 필드
      * 라이프 사이클 : 객체 소멸시 함께 소멸.
        * 변수는 생성자 또는 메소드 수행이 종료되면 소멸
      * 초기화 -> 필드 선성시, 생성자에서
    * 생성자
      * new 연산자로 호출 : 객체 생성시 초기화를 담당.
      * 클래스 이름으로 되어 있고 리턴 타입이 없다.
      * 명시하지 않으면 JVM이 생성. 해주는게 명확하다.
      * 상속 관계에서 객체 생성은 상위클래스가 먼저 초기화 되고 하위 클래스가 초기화 된다.
    * 메소드
      * 객체의 동작. 여러 상호작용.
      * 메소드의 시그니쳐 : 반환타입, 메소드명, 매개변수 등.
  * 메모리 영역
    * Runtime Data Area -> 우리가 영향을 줄 수 있는 영역.
      * 메소드 영역 : 프로그램이 종료되기 전까지 항상 남아있다.
      * 힙 영역 : new로 생성했을때. gc()를 통해서 참조하는 객체가 아무것도 없는 경우 회수. -> 신경쓰지 않으면 성능에 문제가 생겨(특히 서버개발) 힙 영역 규칙 설정 등을 하게된다.
      * 자세한 사항은 Specification 문서 참조.
    * JVM 스택
      * 중괄호 영역 열시 프레임 영역에 쌓인다.
    * Class Loader가 정보를 수집. -> 메소드 영역 -> new를 통해서 만들면 힙 영역에 저장.(new는 공간만 생성. 주소를 반환하면 변수에 담음. 변수는 프레임에 저장.)
      * 과정을 숙지하는것이 클래스 관리 및 효율이 좋아진다.
  * 객체간의 관계 : 사용, 집합, 상속 관계
    * 집합 관계 : 하나는 완성품. 하나는 부품. Aggregation, Composition.
    * 사용 관계 : 객체 간의 상호 작용. 하나의 객체가 다른 객체의 메소드를 호출하여 원하는 결과를 얻어냄.
    * 상속 관계

## 객체지향의 4대 특성
* 캡슐화 Encapsulation
* 상속
* 추상화
* 다형성 (영어도 같이 알아두면 좋다.)
  * 캡슐화 : 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 함.
    * 모두 public으로 하면 내 class를 사용하는 모든 외부 class method의 변수를 고쳐줘야 한다. -> 정보 은닉이 필요.
    * Data(Field)에 해당하는 것은 최대한 감출것. -> Data가 아닌 method에 접근하여 interface에 접근. data는 내 클래스 내에서만 관리. -> 변화에 유연한 대응.
    * 접근 제한자 private -> protected -> default -> public (Default : 같은 패키지에 속해있는 클래스는 접근을 허용하겠다.)
    * Getter / Setter : 무조건 두개를 생성하기보다 필드에 대한 접근은 최대한 막고 메소드에 의한 접근을 허용. 일부 Framework는 강제.
    * 필드 타입이 boolean일 경우 is로 시작하는것이 관례
  * 상속 : 재사용과 확장 -> 빠른 설계 및 쉽게 사용. 중복 코드를 줄여준다.
    * 객체지향에서의 상속은 확장이다.
    * is a 관계 : 하위 클래스는 상위 클래스이다.(LSP - 리스코드 치환 원칙 / Solid L) 하위 클래스 == 상위 클래스 이다.
      * 논리가 맞아야 서로 납득하고 사용할 수 있다.
      * 상위 클래스로 배열 객체를 만든 뒤 하위 클래스 객체를 넣어도 동작한다.
    * 다중 상속 : 자바에서는 다중 상속을 지원하지 않는다. 다이아몬스 상속 문제 때문.(공통적인 동작에서 어떤 것을 실행시켜야 하는가?)
      * 다중 상속 문제를 일으키지 않는 인터페이스를 제공
        * 전부 추상 메서드(시그니쳐만 제공, 하위 클래스에서 구현 요구)
        * 상수 필드 : 클래스에 속하는 변수.
        * 디폴드 메소드 : 하위호환성을 위해 불가피하게 추가.
        * 정적 메소드
      * 익명 클래스 : 일회성의 구현 객체를 만들기 위해서. 람다로 전환 가능(호출할 것이 명확한 경우, 인터페이스 안에 딱 하나의 메소드를 가져야만 함).
    * 추상화 : 관심 영역에 대한 특성만을 가지고 재조합 하는 것.
      * 관심영역 == 어플레케이션 경계 == 도메인 == 컨텍스트
      * 추상화 == 모델링 == 클래스 설계
      * 추상 클래스 : 무조건 하위 클래스를 통해서만 생성.
      * 추상 클래스 vs 인터페이스 : 어떤 것을 사용할 것인가?
        * 추상 메소드만으로 가능한 경우 -> 인터페이스
        * 공통된 구현 부분이나 필요한 경우 -> 추상클래스
        * 개발은 혼자 하는 것이 아니니(다른 사람이 구현했다가 버그가 날 가능성) 무조건 추상클래스만 사용하는 것은 바람직하지 않다.
    * 다형성 : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질.
      * 자동 타입 변환이 가능.
      * 같은 주소를 가리킨다.(상위 하위 클래스 주소)
        * 객체간 == 연산자는 주소 비교
      * 강제 타입 변환 : instanceof로 상속 관계가 맞는지 확인.
    * 오버라이딩(Overriding) : 하위 클래스에서 동일한 메소드를 재정의.
      * 접근 제한을 더 강하게 오버라이딩 할 수 없다(public -> private X). 그 반대는 가능.
    * 오버 로딩(Overloading) : 클래스 내에 같은 이름의 메소드를 여러개 선언 하는것.
      * 혼동되어 쓰지 않도록 주의.
* Tip) 프로젝트 생성
  * `gradle` : Java Package Project 관리 툴
    * 외부 dependency에 대한 library를 명시하여 포함(maven과 비슷) 할 수 있다.
      * http://search.maven.org 에서 원하는 package명을 검색해서 dependencies 영역에 `compile ~` 부분을 복사하여 붙여넣기 하면 적용된다.
    * ```gradle init --type java-library```

## 그 외
* Call By
  * Call By Value : 값에 의한 전달(기본 자료형 int, double, long 등... 단, Integer도 객체가 복사되어 전달.) -> 복사 되어 전달
  * Call By Reference : 참조 / 주소에 의한 전달 -> 주소값을 대입하여 힙영역에 존재하는 객체 참조. 포인터.
* Static : 클래스에 고정된 멤버. static 요소들은 클래스 이름으로 접근하는 것이 좋다.
  * 연산에 의해 초기화가 필요한 경우 statuc 블럭을 사용.
* Final : 초기값이 저장되면 실행 도중 수정할 수 없다.
  * final 메서드 : 오버라이딩 불가능 / final class : 상속 불가능
  * 상수 이름은 모두 대문자로 하는 것이 관례.

## 참고
* 스프링 입문을 위한 자바 객체지향의 원리와 이해 - 김종민(위키북스)
